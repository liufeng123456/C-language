**结构体**
	结构是一些值的集合，这些值称为成员变量，并且这些成员变量可以是不同类型的；
**一、结构体类型的声明**

```
struct tag//结构体类型名称
{
	member-list;//成员变量列表
}variable-list;//结构体变量
```
还有一种特殊的声明，就是匿名结构体。即省略结构体类型的名称

```
struct{
   int a;
   char b;
   float c;
}x;//省略了结构体类型的名称，但其在实际编程中没有太大的意义。
```
**二、结构体的自引用**
即在结构体中包含一个该结构体本身的成员

```
struct S1{
int a;
struct S1 next;
};//这样也是不行的，因为struct S1还没定义完，你就去进行调用显然是错的。
```
正确的自引用方式

```
struct S1{
int a;
struct S1* next;
};//struct S1* next是一个指针，四个字节，所以这个结构体的大小是确定的，这样才可以进行自引用。
```
**三、结构体的内存对齐**
内存对齐对于结构体来说是一个最重要的知识点，并且在面试中也是一个经常考的考点，所以掌握
这个知识点对于我们来说还是极其重要的。要想熟练的掌握内存对齐，就必须知道它对齐的规则是什么？接下来就为大家脑补一下结构体的四条对齐规则：

- 第一个成员在与结构体变量偏移量为0的地址处

```
struct s1{
char a;
int b;
}s;
printf("%p\n",&s);
printf("%p\n",&s.a);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019041819582695.png)
从运行的结果我们可以看出，结构体内第一个成员变量a与结构体s1的地址相同。说明第一个成员a的偏移量为0。

- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
**对齐数** = 编译器默认的一个对齐数与该成员大小的较小值。vs的默认值为8，Linux默认值为4；

```
struct s2{
	char a;
	int b;
	char c;
	}s;
	printf("%d\n",sizeof(s));
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190423150940429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE0NDU4,size_16,color_FFFFFF,t_70)

- 3、结构体总大小为最大对齐数（每一个成员变量都有一个对齐数）的整数倍
接着上面的例子说：
c是一个字节，并且根据规则二，前面的字节数也是c这个变量的对齐数的整数倍，那么是不是就意味着结构体的总大小就是9呢？我们先看一下结果是多少再来讲解。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190423151623405.png)
而结果为12，那么这个结果怎么来的呢？
根据规则3：结构体总大小为最大对齐数（每一个成员变量都有一个对齐数）的整数倍。这个结构体的最大对齐数为4，所以这个结构体总大小要为4的整数倍。前面的总字节为9，所以还要再凑3个字节，凑成4的整数倍，所以这个结构体的总大小为12。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190423153020922.png)
- 4、如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

```
struct s3{
	char a;
	struct s2 s;//上一个例子的结构体
	double c;
}ss;
```
那么这个结构体总大小为多少？
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190423154048123.png)
根据规则4：嵌套的结构体对齐到自己的最大对齐数的整数倍处，所以这个例子中的struct s2 s的对齐数就为4。根据规则二，这个嵌套的结构体要对齐到4的整数倍处。而前面的a为一个字节，所以要在a后面补3个字节，则前两个的大小就为16。第三个成员变量对齐数为8，满足规则2。加起来总共为24，满足规则3，所以结构体总大小为24。

																		 
